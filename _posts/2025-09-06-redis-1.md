---
title: "🎱 Redis를 도입해서 캐싱 작업을 진행해보자!!! [1탄]"
layout: post
categories: [redis]
tags: [redis, NoSQL]
toc: true
toc_sticky: true
toc_label: 목차
author_profile: true
permalink: /redis/1
---

# 🖤 Intro

이번에 추천 시스템을 구성하면서 추천 시스템안에서 사용할 유저 정보를 캐싱해두기 위해 memoryDB인 REDIS를 도입하기로 하였다.

그러나 나의 경우는, REDIS의 개념이나 사용 방법만 알고 이것을 실제로 사용해본적은 없기 때문에….이번 기회를 통해 REDIS의 가장 대표적인 기능인 “캐싱”을 하는 방법을 알아보고자 한다.

REDIS도 활용 방법이 워낙 많고 깊게 쓰자면 딥하게 쓰는 것도 가능하지만, 우리는 시간이 없고 바로 프로젝트에 이것을 적용해야 하는 상황이기에,,, 딱 캐싱에 초점을 맞춰서 스터디를 진행해보고자 한다.

# 🩶 Start

## 레디스란 무엇일까?

레디스는 오픈소스로, key-value 기반의 인-메모리 데이터 저장소이다. 따라서 따로 쿼리를 날릴 필요 없이 key로 값을 조회할 수 있고, 디스크에 데이터를 쓰는 구조가 아닌, 메모리상에서 데이터를 처리하는 메모리DB 이기 때문에 속도가 매우 빠르다는 장점이 있다.

그래서 주로 캐싱하는 용도로 많이 사용하기도 한다.

그렇다면 레디스를 캐싱 용도로 사용하고자 한다면, 캐싱과 DB가 어떤 관계성을 가지는지를 먼저 알아야 한다. 이를 정리하면 다음과 같다.

### 1. 조회 로직 (Look Aside Cache, Read Path)

이는 사용자가 데이터를 조회(읽기)할 때, 어떤 순서로 동작하는가를 말한다. 순서를 정리하면 다음과 같다.

우선 클라이언트가 서버에 데이터를 요청한다. 이때 서버는 바로 DB에 접근하는 것이 아니라 캐시에 먼저 데이터가 있는지를 확인한다.

여기서 데이터가 있다면 바로 캐시에서 데이터를 가져와서 응답한다.

데이터가 캐시에 없다면 DB에서 먼저 조회한 후, 그 결과를 캐시에 저장한 다음 클라이언트에게 전달한다. 즉, 이렇게 한 번 캐시에 저장되고 나면 다음에 데이터를 꺼내 쓸 때는 캐시에서 바로 데이터를 꺼내 쓸 수 있게 된다.

### 2. 저장 로직

이는 사용자가 데이터를 저장(쓰기) 할 때 어떤 순서로 동작하는지를 말한다. 순서를 정리하면 다음과 같다.

우선 클라이언트가 서버에 데이터 저장을 요청한다.

이때, 서버는 바로 DB에 저장을 요청하지 않고, 우선 캐시에 먼저 저장한다음 클라이언트에게 응답한다. 이를 통해 빠른 응답이 가능하다.

이후 별도의 Worker(비동기 처리한다.)가 캐시의 데이터를 한 번에 모아서 DB에 저장한다.

이렇게 하면 모든 요청 마다 저장하는게 아니라, DB에는 한 번에 벌크쿼리를 처리해서 데이터를 INSERT 할 수 있기 때문에 성능 향상을 기대할 수 있다.

## Redis 설치하기

redis의 경우는 CLI 방식이 있고 **GUI 방식으로 동작도 가능하다.**

나의 경우는 아무래도 CLI 방식이 더 편하기 때문에 이 방식으로 진행하기로 하였다.

우선 Redis를 로컬에 설치해보자.

[Run Redis Open Source on Windows using Docker](https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/windows/)

공식문서를 보면, REDIS를 window에서 사용하기 위해서는  docker를 사용해서 띄워야 한다고 한다. 막간을 이용해서 왜 REDIS를 window에서 사용하려면 docker를 사용해야 하는지를 먼저 알아보자.

### REDIS를 window에서 사용하려면 왜 docker를 사용해야 할까?

공식 REDIS가 윈도우용 네이티브 빌드를 더이상 제공하지 않기 때문이다. Redis 자체가 오버커밋 리눅스 커널에 많은 부분을 의존하고 있기 때문에, 결국 docker를 이용해서 컨테이너로 리눅스 환경을 통해 Redis에 접근해야 하는 것이다.

그러므로 공식 문서에 있는대로, docker를 이용해서 REDIS를 띄워보도록 하자.

## Docker를 통해 REDIS 띄우기

```PowerShell
docker run -d --name redis -p 6379:6379 `
  -v C:/developer/GitHub/5th__sinhhanDStudy/redis/redis-docker/redis.conf:/usr/local/etc/redis/redis.conf `
  redis:7 `
  redis-server /usr/local/etc/redis/redis.conf

```

이를 통해 docker desktop에서 redis 최신 버전 이미지를 빌드해서 설치해준다

```PowerShell
docker exec redis redis-cli -a mySecret! PING  # PONG 나오면 정상
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
PONG
```

참고로, 비밀번호가 제대로 설정되었는지 보려면 다음의 명령어를 설정해주면 된다.

```PowerShell
$ docker exec -it redis redis-cli
```

다음 명령어를 통해 docker container에서 redis-cli를 실행한다.

```PowerShell
$ docker exec -it redis redis-cli
127.0.0.1:6379>
```

이렇게 local 서버와 redis를 위한 port에 연결 되었다면, 정상적으로 연결된 것이다.

![image.png](/images/2025-09-06-redis-1/1.png)

참고로, 비밀번호가 제대로 설정 되었다고 나온다면 인텔리제이에 REDIS 연동이 가능하다.

레디스 도커 이미지는 기본적으로 내부에 내장된 redis.conf (설정 파일)을 사용한다. 여기서 우리가 원하는 커스텀 설정 (예: 비밀번호 설정, 포트 변경, 최대 메모리 제한 등)을 적용하려면, **내 설정 파일(redis.conf)** 을 컨테이너 안으로 가져와야한다.

특히 나의 경우는, REDIS에 비밀번호를 걸어뒀기 때문에, 다음 설정값을 넣어주었다. REDIS에 비밀번호를 걸고 싶다면 redis.conf에 다음 값을 넣어줘야 한다.

```PowerShell
requirepass ~~~~~
```

참고로 당연하지만, .conf 파일에는 비밀번호와 같은 설정값들이 들어가 있기 때문에 절대 github에 올려서는 안된다.

redis.conf에 redis에 필요한 설정 값들을 넣어줬다면, docker로 redis를 띄웠기 때문에 Dockerfile을 이용해서 Docker 컨테이너 내부의 경로로 복사해서 설정 값을 넣어줘야 한다.

그래서 다음과 같은 Dockerfile을 작성해준다.

```dockerfile
FROM redis
COPY redis.conf /usr/local/etc/redis/redis.conf
CMD [ "redis-server", "/usr/local/etc/redis/redis.conf" ]
```

```PowerShell
내프로젝트/
├── Dockerfile
├── redis.conf  ← 내가 만든 설정 파일 (호스트에 있음)
└── src/
```

결국, 이 위치에 있는 conf 파일을 복사해서 docker 환경에 주입해주는 것이다. 이를 통해 우리가 작성한 redis 설정 파일을 docker 환경에 주입해서, local과 같은 환경에서 활용이 가능하다.

```PowerShell
$ docker exec -it redis redis-cli
127.0.0.1:6379> ping
PONG
127.0.0.1:6379>
```

참고로 REDIS 연결을 확인하는 방법은 다음과 같다.

docker exec -it redis redis-cli를 통해 REDIS에 CLI로 접근하고, PING을 입력하면 PONG이 나오는 식으로 연결을 확인할 수 있다.

## 키 네이밍 규칙

REDIS의 경우, DB처럼 테이블이 있는게 아니라 모든 데이터가 Key-value인 NoSql이다. 그러므로 기본적으로 key를 계층적으로 나눠 주는 것이 규칙이다. (일종의 컨벤션이라고 할 수 있다.)

예를 들어, userId 123인 유저의 profile을 저장하고 싶다고 하면, 다음과 같이 저장한다.

```java
user:123:profile
```

이 데이터 정보를 만약, TTL 10분동안만 유지하고 싶다고 하면, 다음과 같이 저장하면 된다.

```java
set user:123:profile "유저프로필~" EX 600
```

그렇다면, 우리 프로젝트에서 처럼 user의 특정 정보를 묶어서 저장하고 싶다고 한다면 어떻게 하면 좋을까?
정답은, HSET을 이용하는 것이다.

```java
HSET user:123 userId 123 name "오선정" hobbies "등산,독서" recentMerchants "스타벅스,쿠팡" creditLimit 5000000 creditLeft 3200000
```

이런식으로 HSET으로 저장을 하면, 다음과 같은 구조로 저장이 되는 것이다.

```java
user:123 → {
   "userId": "123",
   "name": "오선정",
   "hobbies": "등산,독서",
   "recentMerchants": "스타벅스,쿠팡",
   "creditLimit": "5000000",
   "creditLeft": "3200000"
}
```

이 구조는, user:123가 key이고, 그 안에 들어있는 값들이 SET의 형태로 저장되는 것이다. `HSET`은 Redis 4.0부터 여러 필드를 한 번에 넣는 걸 공식 지원하고 있어서, 이런식의 구조가 가능하다고 한다.

여기까지 하면 기본 설정 및 우리 프로젝트에 필요한 기본 개념에 대한 정리는 끝이다.

그러나, 여기서 과연 필요한 DATA들을 REDIS에 어떠한 형태로 값을 저장할지에 대한 고민이 있었다…. 이 부분은 다음편에
