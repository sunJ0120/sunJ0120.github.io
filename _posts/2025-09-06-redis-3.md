---
title: "🎱 Redis를 도입해서 캐싱 작업을 진행해보자!!! [3탄]"
layout: post
categories: [redis]
tags: [redis, NoSQL]
toc: true
toc_sticky: true
toc_label: 목차
author_profile: true
permalink: /redis/3
---

# 🖤 Intro

오늘 알아볼 것은, 우리가 구성한 Redis를 이용한 Service 코드를 어떻게 활용해야 할지를 test code로 알아보고자 한다

그와 함께, test code가 아닌 환경에서 개발할때 우리가 이 구조를 어떻게 활용해서 서비스를 구성할 수 있을지를 미리 살펴보자.

# 🩶 Start

```java
/*
현재 우리는 docker container 위에 redis가 있으므로, docker를 자동으로 실행해서 test를 진행하도록 하자.
캐싱 기능 & 캐시 히트 및 미스가 정상적으로 동작하는 것을 볼 수 있다.
*/
@Testcontainers
@SpringBootTest
@Slf4j
class MemberServiceCacheTest {

    private static final String REDIS_PASSWORD = System.getenv().get("REDIS_PASSWORD");

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:7")
            .withExposedPorts(6379)
            .withCommand("redis-server", "--requirepass", REDIS_PASSWORD);

    @DynamicPropertySource
    static void redisProps(DynamicPropertyRegistry r) {
        r.add("spring.data.redis.host", () -> redis.getHost());
        r.add("spring.data.redis.port", () -> redis.getMappedPort(6379));
        r.add("spring.data.redis.password", () -> REDIS_PASSWORD);
    }

    @Autowired
    MemberService memberService;

    @MockitoBean
    MemberRepository memberRepository; // DB 대신 목

    @Autowired
    RedisTemplate<String, Object> redisTemplate; // 내가 정의한 커스텀 템플릿 이용

    @BeforeEach
    void flush() {
        redisTemplate.getConnectionFactory().getConnection().serverCommands().flushDb();
    }

    @Test
    void redis_actually_stores_cache() {
        Long id = 1L;
        Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(7000);

        // Redis가 비어있는지 확인
        Set<String> keysBefore = redisTemplate.keys("*");
        log.info("Redis keys before: {}", keysBefore);

        // 첫 번째 호출 - 캐시 저장됨
        int balance = memberService.getBalance(id);
        assertThat(balance).isEqualTo(7000);

        // Redis에 키가 생겼는지 확인
        Set<String> keysAfter = redisTemplate.keys("*");
        log.info("Redis keys after: {}", keysAfter);

        // 저장된 값들 출력해보기
        for (String key : keysAfter) {
            Object value = redisTemplate.opsForValue().get(key);
            Long ttl = redisTemplate.getExpire(key);
            log.info("Key : {}, Value : {}, TTL : {} seconds",key,value,ttl);
        }

        // Repository는 1번만 호출됨 (왜냐면.. 캐싱이 되었기 때문이다.)
        Mockito.verify(memberRepository, Mockito.times(1)).findBalanceByMemberId(id);
    }

    @Test
    void redis_stores_different_cache_types() {
        //test에 사용하기 위한 객체들
        Long id = 1L;
        MemberCachingDto dto = MemberCachingDto.builder()
                .name("피용희")
                .creditLimit(100000)
                .build();
        int balance = 5000;
        String hobby = "축구";

        // Repository Mock 설정
        Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(balance);
        Mockito.when(memberRepository.findHobbyByMemberId(id)).thenReturn(hobby);
        Mockito.when(memberRepository.findDtoByMemberId(id)).thenReturn(dto);

        System.out.println("=== 캐시 저장 전 ===");
        Set<String> keysBefore = redisTemplate.keys("*");
        log.info("Redis keys: {}",keysBefore);

        // 여러 종류 캐시 저장
        balance = memberService.getBalance(id);
        hobby = memberService.getHobby(id);
        dto = memberService.getSnapshot(id);

        System.out.println("=== 캐시 저장 후 ===");
        log.info("Balance: {}, Hobby: {}, dto : {}",balance,hobby,dto);

        Set<String> keysAfter = redisTemplate.keys("*");
        log.info("Redis keys: {}",keysAfter);

        // 모든 저장된 데이터 출력
        for (String key : keysAfter) {
            Object value = redisTemplate.opsForValue().get(key);
            Long ttl = redisTemplate.getExpire(key);
            log.info("Key: {}",key);
            log.info("Value: {}",value);
            log.info("TTL: {} seconds",ttl);
            log.info("Type: {}",redisTemplate.type(key)); //int, String, dto 나와야 한다.
        }
        assertThat(keysAfter.size()).isGreaterThanOrEqualTo(3); // balance, hobby, dto 최소 3개
    }

    @Test
    void redis_cache_hit_verification() {
        Long id = 1L;
        Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(9999);

        System.out.println("=== 첫 번째 호출 (캐시 미스) ===");
        int result1 = memberService.getBalance(id);
        Set<String> keys1 = redisTemplate.keys("*");
        log.info("Result: {}",result1);
        log.info("Redis keys: {}", keys1);

        // Repository Mock을 다른 값으로 변경 (캐시 히트면 이 값이 안나와야 함...바뀌기 전 값이 와야 하니까)
        Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(1111);

        System.out.println("=== 두 번째 호출 (캐시 히트) ===");
        int result2 = memberService.getBalance(id);
        Set<String> keys2 = redisTemplate.keys("*");
        log.info("Result: {}",result2);
        log.info("Redis keys: {}", keys2);

        // 캐시에서 가져온 값이므로 첫 번째와 같아야 함 (9999)
        assertThat(result2).isEqualTo(9999);
        assertThat(result2).isNotEqualTo(1111); // Mock의 새 값이 아님

        // Repository는 1번만 호출됨 (캐시 히트)
        Mockito.verify(memberRepository, Mockito.times(1)).findBalanceByMemberId(id);

        log.info("캐시 히트 성공! Repository는 {}이고, {}번만 호출",result2,Mockito.mockingDetails(memberRepository).getInvocations().size());
    }
}
```

전체 test code는 다음과 같다. 여기서 이제 각각의 테스트 method가 무엇을 의미하는지, 각 설정은 무엇을 의미하고 왜 달아뒀는지를 상세히 알아보고자 한다.

## Test code 0_레디스 테스트 환경 설정

```java
private static final String REDIS_PASSWORD = System.getenv().get("REDIS_PASSWORD");

@Container
static GenericContainer<?> redis = new GenericContainer<>("redis:7")
        .withExposedPorts(6379)
        .withCommand("redis-server", "--requirepass", REDIS_PASSWORD);

@DynamicPropertySource
static void redisProps(DynamicPropertyRegistry r) {
    r.add("spring.data.redis.host", () -> redis.getHost());
    r.add("spring.data.redis.port", () -> redis.getMappedPort(6379));
    r.add("spring.data.redis.password", () -> REDIS_PASSWORD);
}

@Autowired
MemberService memberService;

@MockitoBean
MemberRepository memberRepository; // DB 대신 목

@Autowired
RedisTemplate<String, Object> redisTemplate; // 내가 정의한 커스텀 템플릿 이용

@BeforeEach
void flush() {
    redisTemplate.getConnectionFactory().getConnection().serverCommands().flushDb();
}
```

이 부분이 바로 redis password를 주입하고 docker container를 test 환경에서 띄울 수 있도록 하는 부분이다. 또한,  순수한 환경의 test를 위해 REDIS 저장소를 한 번 비워주는 역할을 하기도 한다.

하나씩 뜯어보자.

```java
private static final String REDIS_PASSWORD = System.getenv().get("REDIS_PASSWORD");

@Container
static GenericContainer<?> redis = new GenericContainer<>("redis:7")
        .withExposedPorts(6379)
        .withCommand("redis-server", "--requirepass", REDIS_PASSWORD);
```
나의 경우는, .env 안에 모든 설정 파일의 변수를 빼두었는데, 이를 가져와서 쓰기 위함이다. System.getenv()를 통해 env를 가져와서 그 안에 있는 REDIS_PASSWORD를 사용한다.

GenericContainer<>("redis:7")은 redis:7 이미지를 기반으로 컨테이너를 생성하는 것이다. .withExposedPorts(6379)를 통해서 컨테이너의 6379 포트를 호스트의 **랜덤 가용 포트**로 매핑하는데, 우리가 docker로 redis 이미지를 띄울때 6379 포트를 사용했으므로 맞춰준다.

.withCommand("redis-server", "--requirepass", REDIS_PASSWORD)를 이용해서 기본 엔트리포인트를 덮어써서 **비번이 걸린 Redis**로 실행할 수 있게 된다. 여기서 사용하는 패스워드는 환경변수로 빠져 있는 REDIS_PASSWORD이고, "redis-server", "--requirepass" 이 명령어는 redis를 비밀번호로 실행하는 방법에는, cmd로 입력하는 방법과 나의 실습 처럼 .conf로 입력하는 방법이 있는데 그 중 cli로 입력하는 방법을 사용한 것이다.

```PowerShell
redis-server --requirepass mypassword
```

실제로 이런 느낌으로 실행된다. 

```java
@DynamicPropertySource
static void redisProps(DynamicPropertyRegistry r) {
    r.add("spring.data.redis.host", () -> redis.getHost());
    r.add("spring.data.redis.port", () -> redis.getMappedPort(6379));
    r.add("spring.data.redis.password", () -> REDIS_PASSWORD);
}
```

@DynamicPropertySource를 통해 테스트 컨테이너에서 얻은 동적 값 (포트, 호스트 등)을 Spring Boot 설정(application.yml)에 등록해준다. 즉, 컨테이너를 띄우는 코드를 작성했으니, 이를 통해 설정 파일에 등록한다.

host를 통해 host와 연결하고, port를 통해 랜덤 가용 포트를 부트로 연결한다.(컨테이너 내부 포트가 6379인 것이고, 호스트는 랜덤 가용 포트로 연결된다.) 이렇게 하면 RedisTemplate가 제대로 연결될 수 있다.

그리고 마지막으로는 password를 통해 REDIS_PASSWORD를 주입받는다. 이렇게 해서 컨테이너에 있는 정보를 스프링 부트에 연결해준다.

```java
@Autowired
MemberService memberService;

@MockitoBean
MemberRepository memberRepository; // DB 대신 목

@Autowired
RedisTemplate<String, Object> redisTemplate; // 내가 정의한 커스텀 템플릿 이용

@BeforeEach
void flush() {
    redisTemplate.getConnectionFactory().getConnection().serverCommands().flushDb();
}
```

@MockitoBean를 통해서 `MemberRepository`의 **Mockito 목 객체**를 등록한다. 실제 JPA 리포지토리 빈을 대신/대체해서 주입되므로 DB를 전혀 타지 않는다는 특징이 있다.

RedisTemplate<String, Object> redisTemplate을 통해 내가 정의한 커스텀 템플릿을 가져와서 사용하도록 한다.

## Test code 1_레디스 캐싱 테스트

```java
@Test
void redis_actually_stores_cache() {
    Long id = 1L;
    Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(7000);

    // Redis가 비어있는지 확인
    Set<String> keysBefore = redisTemplate.keys("*");
    log.info("Redis keys before: {}", keysBefore);

    // 첫 번째 호출 - 캐시 저장됨
    int balance = memberService.getBalance(id);
    assertThat(balance).isEqualTo(7000);

    // Redis에 키가 생겼는지 확인
    Set<String> keysAfter = redisTemplate.keys("*");
    log.info("Redis keys after: {}", keysAfter);

    // 저장된 값들 출력해보기
    for (String key : keysAfter) {
        Object value = redisTemplate.opsForValue().get(key);
        Long ttl = redisTemplate.getExpire(key);
        log.info("Key : {}, Value : {}, TTL : {} seconds",key,value,ttl);
    }

    // Repository는 1번만 호출됨 (왜냐면.. 캐싱이 되었기 때문이다.)
    Mockito.verify(memberRepository, Mockito.times(1)).findBalanceByMemberId(id);
}
```

우선, redisTemplate.keys("*");을 통해 현재 연결된 redis에 키가 존재하는지를 확인한다. 아직 캐싱하지 않았으므로 키는 존재하지 않을 것이다.

memberService.getBalance(id)를 통해 넣으면, 내부 로직에서 캐싱이 되어 있지 않을 경우 db에서 값을 찾아서 저장하는 부분이 구현되어 있으므로 cache에 저장한 후 값을 가져올 수 있다.

redisTemplate에서는 redisTemplate.opsForValue().get(key); 이걸 통해 value값을 Object 타입으로 가져올 수 있다. (get을 통해 key를 사용해서) 이렇게 가져온 값을 꺼내보면, 우리가 넣어준 값인 7000이라는 balance 값이 잘 들어가 있는 것을 볼 수 있다.
memberRepository는, 초반에 캐시가 없을 때 한 번만 호출되므로, 총 호출횟수는 한 번이 되어 test를 통과할 수 있다.

```java
2025-09-05T19:55:51.692+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Redis keys before: []
2025-09-05T19:55:51.704+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Redis keys after: [v1:bal:user:1]
2025-09-05T19:55:51.712+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Key : v1:bal:user:1, Value : 7000, TTL : 180 seconds
```

## Test code 2_레디스 캐싱 테스트 - 각기 다른 형태의 객체가 잘 저장 되는지에 관하여

```java
@Test
void redisStoresDifferentCacheTypes() {
    //test에 사용하기 위한 객체들
    Long id = 1L;
    MemberCachingDto dto = MemberCachingDto.builder()
            .name("피용희")
            .creditLimit(100000)
            .build();
    int balance = 5000;
    String hobby = "축구";

    // Repository Mock 설정
    Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(balance);
    Mockito.when(memberRepository.findHobbyByMemberId(id)).thenReturn(hobby);
    Mockito.when(memberRepository.findDtoByMemberId(id)).thenReturn(dto);

    System.out.println("=== 캐시 저장 전 ===");
    Set<String> keysBefore = redisTemplate.keys("*");
    log.info("Redis keys: {}",keysBefore);

    // 여러 종류 캐시 저장
    balance = memberService.getBalance(id);
    hobby = memberService.getHobby(id);
    dto = memberService.getSnapshot(id);

    System.out.println("=== 캐시 저장 후 ===");
    log.info("Balance: {}, Hobby: {}, dto : {}",balance,hobby,dto);

    Set<String> keysAfter = redisTemplate.keys("*");
    log.info("Redis keys: {}",keysAfter);

    // 모든 저장된 데이터 출력
    for (String key : keysAfter) {
        Object value = redisTemplate.opsForValue().get(key);
        Long ttl = redisTemplate.getExpire(key);
        log.info("Key: {}",key);
        log.info("Value: {}",value);
        log.info("TTL: {} seconds",ttl);
        log.info("Type: {}",redisTemplate.type(key)); //int, String, dto 나와야 한다.
    }
    assertThat(keysAfter.size()).isGreaterThanOrEqualTo(3); // balance, hobby, dto 최소 3개
}
```

우리의 경우는 cache에 넣는 값들을 다 다른 타입으로 정의했기 때문에 각각이 잘 저장되었는지 살펴봐야 한다.

balance = memberService.getBalance(id);
hobby = memberService.getHobby(id);
dto = memberService.getSnapshot(id);

해당 get 값들은 우선 캐시에 없으면 db에서 캐시에 저장한다음 return 하도록 설정했기 때문에, 우리가 원하는 value 값들이 나올 것이다.

for문을 통해 redisTemplate에서 key로 가져온 value 값을 확인해서, 각각의 value들이 잘 나오는지를 살펴보자.

결과를 보면, 우리가 원했던 대로 각각이 다른 value 형태로 잘 나오는 것을 볼 수 있다. (마지막은 dto 타입으로 바로 나오도록 구성했다.)

```java
=== 캐시 저장 전 ===
2025-09-05T19:55:51.049+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Redis keys: []
=== 캐시 저장 후 ===
2025-09-05T19:55:51.359+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Balance: 5000, Hobby: 축구, dto : MemberCachingDto(name=피용희, creditLimit=100000)
```

## Test code 3_레디스 캐싱 테스트 - 캐시히트 테스트

```java
 @Test
void redisCacheHitVerification() {
    Long id = 1L;
    Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(9999);

    System.out.println("=== 첫 번째 호출 (캐시 미스) ===");
    int result1 = memberService.getBalance(id);
    Set<String> keys1 = redisTemplate.keys("*");
    log.info("Result: {}",result1);
    log.info("Redis keys: {}", keys1);

    // Repository Mock을 다른 값으로 변경 (캐시 히트면 이 값이 안나와야 함...바뀌기 전 값이 와야 하니까)
    Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(1111);

    System.out.println("=== 두 번째 호출 (캐시 히트) ===");
    int result2 = memberService.getBalance(id);
    Set<String> keys2 = redisTemplate.keys("*");
    log.info("Result: {}",result2);
    log.info("Redis keys: {}", keys2);

    // 캐시에서 가져온 값이므로 첫 번째와 같아야 함 (9999)
    assertThat(result2).isEqualTo(9999);
    assertThat(result2).isNotEqualTo(1111); // Mock의 새 값이 아님

    // Repository는 1번만 호출됨 (캐시 히트)
    Mockito.verify(memberRepository, Mockito.times(1)).findBalanceByMemberId(id);

    log.info("캐시 히트 성공! Repository는 {}이고, {}번만 호출",result2,Mockito.mockingDetails(memberRepository).getInvocations().size());
}
```

첫번째 호출의 경우는, mock에 저장된 후 캐싱된 값이 아직 없기 때문에 캐시 미스가 발생할 것이다.

캐시 미스가 발생할 경우, db에서 가져온 정보인 9999를 저장하게 되어 9999라는 값이 저장된다

캐시 히트 테스트는, 캐시에 값이 이미 있어서 db에서 값을 바꿔도 캐시에 값이 남아있는 것을 확인하기 위함이다.

Mockito.when(memberRepository.findBalanceByMemberId(id)).thenReturn(1111);를 통해 mock의 값을 1111로 바꿨지만, 아직 캐시 안의 TTL이 만료되지 않았기 때문에 assertThat(result2).isEqualTo(9999);가 true로 나오고, assertThat(result2).isNotEqualTo(1111);가 true로 나온다.

실제로 Mockito.mockingDetails(memberRepository).getInvocations().size()를 찍어보면, 처음 캐시 미스일때 딱 한번만 호출된 것을 볼 수 있다.

```java
=== 첫 번째 호출 (캐시 미스) ===
2025-09-05T19:55:51.644+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Result: 9999
2025-09-05T19:55:51.645+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Redis keys: [v1:bal:user:1]
=== 두 번째 호출 (캐시 히트) ===
2025-09-05T19:55:51.654+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Result: 9999
2025-09-05T19:55:51.654+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : Redis keys: [v1:bal:user:1]
2025-09-05T19:55:51.669+09:00  INFO 1920 --- [    Test worker] s.r.service.MemberServiceCacheTest       : 캐시 히트 성공! Repository는 9999이고, 1번만 호출
```

## 전체 test 결과

![image.png](/images/2025-09-06-redis-3/2.png)

테스트도 이쁘게 통과된 것을 볼 수 있다:)

